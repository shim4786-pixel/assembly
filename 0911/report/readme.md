[Short Answer Part 1](short-answer/part1.md)  
[Short Answer Part 2](short-answer/part2.md)  
[Short Answer Part 3](short-answer/part3.md)  
[Short Answer Part 4](short-answer/part4.md)  
[Algorithm Workbench](Algorithm-Workbench.md)  
reference  
-Copilot  
-Assembly Language for x86 Processors 7th Edition  
---
# 0911 강의 정리  

## 언어에 관하여  
언어는 **자연어**와 **인공어**로 나눌 수 있다.  
-**자연어(natural language):** 한국어, 영어 불어 등 사람들이 소통하는 언어   
-**인공어(artificial language):** 인간이 인공물을 만들고, 그와 소통하기 위해 인간들이 사용하는 언어  
  -인공어의 경우 크게 3단계로 나뉠 수 있는데, 기계어/ 어셈블리 언어/ 고급 언어이다.  

---
## 번역자  
인공어를 번역해주는 대표적인 예로 **컴파일러**와 **인터프리터**가 있는데, 모두 고급 언어를 기계어로 번역하는 데 이바지한다는 점에서 동일하다.  
하지만 둘은 확실히 다르다. 번역하는 고급 언어의 차이도 있고 방식에도 차이가 있다.  
**컴파일러 기반 언어:** C, C++ 등..  
**인터프리터 기반 언어:** Pythone, JavaScript 등..  
**하이브리드 방식:** Java, C#, Pyrhon 등..  

하이브리드는 컴파일 + 인터프리터의 조합으로 이루어지는데 방법을 간단히 알아보자면  
-컴파일러가 사람이 작성한 고급 언어를 **바이트코드**로 변환 >> 변환된 **바이트코드**를 **가상머신**이 해석하고 실행  
다음과 같이 컴파일러가 변환하고 인터프리터가 실행하는 단계를 거친다.  
ex) Java의 경우 Algorithm Workbench ex8번에서 작성하였듯이 컴파일러(**javac**)가 바이트코드(**.class 파일**)를 만들고 가상머신(**JVM**)이 해당 코드를 해석하고 실행한다.   
(Copilot 자문: 바이트 코드는 운영체제(Windows, Mac, Linux)와 무관하게 실행 가능하고, VM은 실행 중에 성능을 개선할 수도 있고, 보안 관리도 쉽다. 또한 바이트코드 수준에서 오류 추적이 가능해 디버깅이 편리하다.)  

컴파일러는 번역가가 책을 통째로 번역하여 출판하는 방식이고,  
인터프리터는 한 문장씩 동시통역사가 실시간으로 통역해 주는 방식이라면  
하이브리드 방식은 번역가가 책을 중간 언어로 번역하여, 각 나라의 통역사가 그를 자국어로 해석하는 구조이다.  

---
## 어셈블리 언어  
간단히
**어셈블**은 어셈블리 언어를 기계어로 번역하는 과정  
**어셈블러**는 어셈블리 언어를 번역해주는 도구  
**어셈블리 언어**는 그러한 언어이다.  
인터프리터나 컴파일러와는 달리 어셈블러는 고급 언어가 아닌 어셈블리 언어를 번역하는 역할을 하는데,  
통역, 번역가에 빗대면 기계어 말하는 법을 직접 배워서 통역해주는 사람이라고 생각하면 된다.  
기계마다 기계어가 다르기에 그에 대응하는 어셈블리도 다르다.  
우리가 주로 배울 어셈블러는 **MASM**이고, 그 외에 **NASM, GAS**는 리눅스에서도 어셈블리코드 작성이 가능하다고 한다.  

---
## 진법 변환  
보수 : '특정 수에서 얼마만큼 모자란가'의 개념이다.  
2진법에서의 보수는 **음수**를 표현 한다. (**2의 보수법**)  
컴퓨터에서의 보수 사용은 부호를 바꾸어 **덧셈 계산 만으로 뺄셈을 계산**한다는 데에 의의가 있다.  
음수 표현 방법은  
1. 부호화-절댓값 표현  
2. 1의 보수
3. 2의 보수
가 있는데, 이중 2의 보수를 채택한다. 모두 **MSB를 부호 비트로 사용**하는데 2의 보수법이 음수 하나를 더 표현 가능했기 때문이다.(2, 3의 경우 노린건 아니지만 그렇게 하고 보니 음수는 MSB가 모두 1이었던 것이다.)  
r진법에서 사용 가능한 보수는 **r의 보수**와 **r-1의 보수** 단 2종류가 있는데 계산법은 이와같다.  
-r의 보수 : r^n - N  
-r-1의 보수 : r^n - r^-m - N  
  n : 자리수, m : 소수점 이하 자리수, N : 수  
이 방법은 범위내 실수의 계산에서 모두 유효하다.  
하지만 너무 어려우니 **r-1의 보수**를 구하고(2진법의 경우 모든 자리의 0과 1을 교체) +1을 하여 **r의 보수**를 구하는 방법이 제일 쉽다.  
2진법의 2의 보수를 구할 때는 오른쪽부터 1이 나오기 전까지 똑같이 받아적은 뒤 처음 1을 만난 이후부터 모든 자리의 0과 1을 바꾸는 방법으로도 구할 수 있다.  
---
## Questions You Might Ask  
**Q** What Are Assemblers and Linkers?  
**A** 어셈블러는 어셈블리 언어를 기계어로 번역하는 프로그램.   
링커는 여러 개의 번역된 코드(파일)를 하나의 실행 파일로 연결하는 도구이다.  

---
**Q** What Types of Programs Can Be Created Using MASM?  
**A** MASM은 x86 아키텍쳐 기반의 어셈블리 언어를 작성하고 실행할 수 있게 해주는 어셈블러이다.  
이로는 **하드웨어와 밀접하게 연결된 저수준 프로그램**을 만들 수 있는데,  
예를 들면 디바이스(키보드, 프린터, 그래픽카드) 드라이버, 임베디드 시스템 소프트웨어, 게임 엔진의 루틴, 성능을 최적화 한 유틸리티 등이 있다.  
MASM은 직접적인 하드웨어 제어가 가능하고, 보다 빠르고 가벼운 실행으로 실시간으로 반응하는 프로그램을 만드는 데에 적합하다. 또한 운영체제, 컴파일러 내부 구조를 이해하는 데도 도움이 된다.  

---
**Q** How Does Assembly Language Relate to Machine Language?  
**A** 어셈블리 언어는 기계어의 사람이 읽을 수 있는 버전이다.  
ex) MOV AL, 97 -> 10110000 01100001  

---
**Q** How Do C++ and Java Relate to Assembly Language?  
**A** C++, Java 같은 고급 언어는 컴파일러를 통해 어셈블리어 또는 기계어로 변환되어 실행된다.  

---
**Q** Is Assembly Language Portable?  
**A** 위에서 기계마다 기계어가 다르고 그에 호환되는 어셈블러가 다르다고 했듯이 CPU구조에 따라 명령어가 달라지기에 어셈블리는 코드 수정이 필요하다. 이식성(portable)이 낮다고 볼 수 있다.  

---
**Q** Why Learn Assembly Language?  
**A** 어셈블리 언어를 통해 CPU와 메모리의 동작 원리를 더욱 잘 이해할 수 있고, 고급언어보다 기계어에 더 가까운 언어로서 더 빠르고 효율적인 코드 작성이 가능하다. 특히 운영체제, 임베디드 시스템 개발등의 경우에서는 필수이다.  

---
reference  
-Copilot  
-Assembly Language for x86 Processors 7th Edition   
-어셈블리 프로그래밍 1. Basic Concepts    
