reference

---

---
# 1030 수업 정리  
## 스택  
스택은 기본적으로 **LIFO (Last In First Out)** 의 방식을 가지는 주기억장치의 일부이다.  
스택의 맨 위를 **Top**, 맨 아래를 **Bottom**이라 하고  
항상 스택의 Top 주소를 가리키는 레지스터가 ESP이다.(32-bits 에서)   
```asm
.stack
```
으로 정의되는 스택 영역의 시작 주소는 **SS(스택 세그먼트)** 에 저장되고   
스택의 Top 포인터 역할을 하며 스택 영역에서 얼마나 떨어져 있는지를 나타내는 레지스터가 **ESP**이다.  

메모리 영역을 그릴 때는 낮은 주소(위)부터 높은 주소(아래)의 형태로 그리지만  
보통 Stack을 그릴 때는 그와 반대로(높은 주소가 위로 간다) 그린다.  

---
## PUSH와 POP  
스택에 있어서 기본적인 연산 2가지이다.  
자료구조에서 스택에 값을 빼고 넣을 때는 스택 탑 포인터를 사용하는데 어셈블리에서는 SP가 이를 담당한다.  
### PUSH  
```
┌────────────────────────────┐
│ 주소: 00001000             │ ← ESP 
│ 값:   00000006             │
├────────────────────────────┤
│ 주소: 00000FFC             │
│ 값:   (비어 있음)           │
├────────────────────────────┤
│ 주소: 00000FF8             │
│ 값:   (비어 있음)           │
├────────────────────────────┤
│ 주소: 00000FF4             │
│ 값:   (비어 있음)           │
├────────────────────────────┤
│ 주소: 00000FF0             │
│ 값:   (비어 있음)           │
└────────────────────────────┘
```
해당 스택에서 push 명령어는 스택 포인터를 4 감소하고 해당 위치에 값을 넣으라는 지시가 된다.  
```
┌────────────────────────────┐
│ 주소: 00001000             │
│ 값:   00000006             │
├────────────────────────────┤
│ 주소: 00000FFC             │ ← ESP (Top)
│ 값:   000000A5             │
├────────────────────────────┤
│ 주소: 00000FF8             │
│ 값:   (비어 있음)           │
├────────────────────────────┤
│ 주소: 00000FF4             │
│ 값:   (비어 있음)           │
├────────────────────────────┤
│ 주소: 00000FF0             │ 
│ 값:   (비어 있음)           │
└────────────────────────────┘
```
그림을 어떻게 그리느냐에 따라 주소값을 감소해야 하는지, 증가해야 하는지는 달라진다.  

PUSH 명령어에 사용 가능한 오퍼랜드는  
1. 16비트 reg/mem
2. 32비트 reg/mem
3. 32비트 즉시값
이다.  

### POP  
pop 명령어는 반대로 스택 포인터의 값을 빼고 스택 포인터를 4 증가하라는 지시가 될 것이다.  
```
┌────────────────────────────┐
│ 주소: 00001000             │ ← ESP 
│ 값:   00000006             │
├────────────────────────────┤
│ 주소: 00000FFC             │
│ 값:   (비어 있음)           │
├────────────────────────────┤
│ 주소: 00000FF8             │
│ 값:   (비어 있음)           │
├────────────────────────────┤
│ 주소: 00000FF4             │
│ 값:   (비어 있음)           │
├────────────────────────────┤
│ 주소: 00000FF0             │
│ 값:   (비어 있음)           │
└────────────────────────────┘
```
바로 위의 스택에서 pop을 하면 이렇게 될 것이다.  
pop도 마찬가지로 그림을 어떻게 그리느냐에 따라 증가인지, 감소인지는 달라진다.  
별다른 지시가 없을 경우 POP명령어는 묵시적으로 pop한 값을 **EAX**에 가져다 놓는다.  

POP 명령어에 사용 가능한 오퍼랜드는  
1. 16비트 reg/mem
2. 32비트 reg/mem
이다.

스택에 있는 값을 가져와 어딘가에 저장하는 구조이기 때문에 즉시값은 오지 않는다.  

---
## 스택의 값  
스택에 저장되는 값들은 크게 4가지로 분류 가능하다.  
1. 지역 변수(Local Varable Storage) : 함수 내부에서 선언된 변수들  
2. 함수 호출 인자(Argument Passing) : 호출된 함수에 전달되는 인자
3. 레지스터 값(Register Saving) : 함수 호출시 보존해야 할 레지스터 값
4. 복귀 주소 저장(Return Address Storage) : 함수가 끝난 후 돌아가야 할 주소로, call 명령어가 push한다.  

---
## PUSHFD와 POPFD  
32비트 플래그 레지스터를 스택에 넣고 빼는 명령어이다.  

## PUSHAD와 POPAD, PUSHA와 POPA  
8개의 범용 레지스터 값을 모두 스택에 차례대로 저장했다가 다시 복구하는 명령어이다.  
스택에는 EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI 순서대로 들어간다.  
AD는 위와 같은 32비트 레지스터를 대상으로 하고, A는 16비트 레지스터들을 넣고 뺀다.  
여기서 ESP 혹은 SP 값은 PUSHAD를 실행하기 이전의 값이다.  

만약 여러 레지스터를 수정하는 프로시저를 작성했다면 메인 프로시저를 위해 레지스터를 저장하고 복원하기 위해 사용한다.  
```asm
MySub PROC
  pushad
  .
  .
  mov eax, ~~~
  mov ebx, ~~~
  mov ecx, ~~~
  .
  .
  popad
  ret
MySub ENDP
```
하지만 예외적인 사항이 있는데, 만약 해당 프로시저가 EAX의 값을 반환하는 프로시저라면 이를 사용하지 않아야 한다.  
```asm
ReadValue PROC
  pushad
  .
  .
  mov eax, return_value
  .
  .
  popad       ; 반환값이 덮어씌워진다.
  ret
ReadValue ENDP
```
필요한 프로시저가 실행중 중요한 레지스터의 값을 바꿀 것 같다면 push ESI, pop ESI 와 같이 스택에 저장해두면 된다.  
여러개의 레지스터를 push, pop할 때는 스택의 LIFO 특성상 거꾸로 값을 가져오므로 push로 넣었던 반대 순서대로 pop을 해야한다.  
```asm
mov ecx, 100
L1:
  .
  .
  push ecx
L2:
  .
  .
  Loop L2
  pop ecx
  Loop L1
```
다음과 같이 loop안에 loop문이 있을 때 각 루프가 일정 횟수만큼 정확히 돌기위해 ECX를 저장할 수도 있다.  
다만 대개 프로시저들은 리턴 값으로 EAX를 사용하므로 EAX는 push나 pop을 하지 않는게 좋다.(다른 레지스터 사용)  

---
## PROC 디렉티브
고급 언어에서 코딩을 할 때 메소드나 함수를 만들어 개별적인 작업으로 나누곤 하는데,  
어셈블리에서는 이를 **프로시저**라고 한다.  
프로시저는 **PROC**과 **ENDP** 디렉티브를 사용하여 선언되는데, 이름을 부여받아 사용된다.  
```asm
main PROC
.
.
main ENDP

sample PROC
.
.
ret
sample ENDP
```
우리가 사용하던 프로시저는 main이라는 이름의 프로시저로, irvine32.lib를 이용해 exit로 끝나는 시작 프로시저인데  
이와 다르게 시작 프로시저가 아닌 다른 프로시저는 끝에 **ret** 명령어를 가진다.  
이 명령어는 해당 프로시저를 호출했던 위치로 되돌아가게 한다.  

기본적으로 레이블은 선언된 프로시저 내애서만 사용할 수 있다.  
예로
```asm
jmp Destination
```
의 Destination은 jmp 명령어와 같은 프로시저에 있어야 한다.  
다만 콜론을 두 개 찍는 방식으로 해당 제한을 벗어날 수 있다.  
```asm
Destination::
```
전역 레이블을 선언하여 갑자기 main 프로시저로 점프할 수도 있게되는 것이다.

---
## 프로시저의 문서화
각각의 프로시저를 읽기 쉽게 문서화하는 것은 좋은 습관이다.  
프로시저의 시작 부분에  
1. 프로시저가 수행하는 작업에 대한 설명
2. 매개변수(파라미터)의 정의와 사용법
3. 리턴하는 값의 설명
4. 프로시저가 호출되기 이전에 충족되어야 하는 전제조건

을 써주면 좋다.  

---
## CALL과 RET 명령어  
**CALL** 명령어는 프로세서가 새로운 메모리 위치에서 수행을 시작하도록 지시하여 프로시저를 호출하고  
**RET** 명령어는 프로세서가 프로시저를 호출했던 프로그램 위치로 되돌아오게 한다.  
과정은 이러이러하다.  
1. 콜 명령어를 읽고 실행한다.
2. 되돌아갈 주소(IP)를 스택에 PUSH한다.
3. 호출한 프로시저의 주소를 copy하여 IP에 복사한다.
4. 호출한 프로시저를 수행한다.
5. RET 명령어를 읽고 복귀 명령어를 실행한다.
6. 스택에 있는 돌아갈 주소를 IP에 다시 POP한다.
7. 원래 하던 일을 계속 한다.

call과 ret 명령어는 이런 과정을 처리한다.  
자세한 예제는 책이나 pdf에 있는 그림을 참고하면 좋다.  

---
## 레지스터 인수의 프로시저 전달  
```asm
.data
theSum DWORD ?
.code
main PROC
  mov eax, 10000h
  mov ebx, 20000h
  mov ecx, 30000h
  call Sumof      ;EAX = (EAX + EBX + ECX)
  mov theSum, eax
```
위의 예제에서 eax, ebx, ecx,는 인수(argument)이다.  
어셈블리에서는 범용 레지스터를 인수로서 전달하는 것이 일반적이다.  

---
## USES 연산자  
```asm
ArraySum PROC USES esi ecx
  mov eax, 0
L1:
  add eax, [esi]
  add esi, TYPE DWORD
  loop L1
  ret
ArraySum ENDP
```
위와 같이 해당 프로시저에서 사용될 레지스터들을 열거한다.  
이 연산자는 어셈블러가  
1. 프로시저의 시작에 해당 레지스터를 스택에 저장하는 PUSH 명령어를 생성한다.
2. 프로시저의 끝에 레지스터의 값을 복원하는 POP 명령어를 생성한다.

해당 2가지 작업을 하도록 알려준다.  

---
## 링크 라이브러리  
링크 라이브러리는 프로시저들이 저장된 파일로 우리가 입출력 동작을 쉽게 처리할 수 있도록 해준다.(다만 어셈블리에서 기본 제공되는 것은 아니다.)  
**kernel32.lib**파일은 Microsoft Windows 플랫폼 소프트웨어 개발 키트의 일부로 **kernel32.dll**에 위치한 시스템 함수에 대한 링크 정보를 포함한다.  
dll은 동적 링크 라이브러리라고 불린다.  
**kernel32.dll**은 문자 기반 입출력을 수행하는 실행 가능한 함수들을 포함한다.  

기본적으로 우리가 만든 코드들은 컴파일러가 **.obj** 파일을 생성한다.  
이를 링커가 다른 파일(kernel32.lib 등)과 결합하여 **.exe(실행파일)** 를 만드는 것이다.  
보통 Irvine32.lib와 링크하고 필요에 따라 kernel32.lib와 직접 링크할 수도 있다.  
**Irvine32.lib**는 어셈블리 학습용으로 제공되는 라이브러리로, 내부적으로는 kernel32.lib에 의존한다.  

krenel32.lib는 **kernel32.dll**의 함수 주소를 담는데, 링커가 링크해 놓은 단서를 찾아  
실행단계에서 운영체제가 필요한 DLL을 메모리에 로드하여 사용된다.  

물론 이를 실행하기 위해서는 나의 컴퓨터에 kernel32.lib, Irvine32.lib와 DLL이 모두 설치되어 있어야 한다.  
