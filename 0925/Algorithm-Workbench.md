# Algorithm Workbench 문제 풀이

## 문제 1  
**Q: Define four symbolic constants that represent integer 25 in decimal, binary, octal, and hexadecimal formats.**  
**A:** 25를 10진수, 2진수, 8진수, 16진수 형식으로 나타내는 4개의 심볼릭 상수를 정의한다.  
```asm
DEC25 = 25  
BIN25 = 11001b  
OCT25 = 31o  
HEX25 = 19h  
```

---
## 문제 2  
**Q: Find out, by trial and error, if a program can have multiple code and data segments.**  
**A:** 단순히 .data를 여러개 가질 순 없지만
```asm
data1 SEGMENT
a1 DWORD 1234h
data1 ENDS

data2 SEGMENT
a2 DWORD 5678h
data2 ENDS
```
와 같이 **SEGMENT**와 **ENDS**를 사용하니 다수의 데이터 세그먼트를 지정하고도 정상적으로 작동하였다.  
코드 세그먼트 역시 마찬가지로 가능하지는 않지만  
```asm
code1 SEGMENT
main PROC
    ; main 루틴
    ret
main ENDP
code1 ENDS

code2 SEGMENT
other PROC
    ; 보조 루틴
    ret
other ENDP
code2 ENDS
```
와 같은 형식으로 한정된 조건에선 실행이 가능하다고 한다.(Copilot 자문)  

---
## 문제 3  
**Q: Create a data definition for a doubleword that stored it in memory in big endian format.**  
**A:** DWORD를 빅 엔디안 형식으로 저장하도록 데이터를 정의한다. MASM은 빅 엔디안을 따로 지원하지 않으므로 수동으로 처리한다.  
```asm
.data
big BYTE 12h, 34h, 56h, 78h
```

---
## 문제 4  
**Q: Find out if you can declare a variable of type DWORD and assign it a negative value. What does this tell you about the assembler’s type checking?**  
**A:** DWORD 에 음수값을 넣어 결과를 알아본다.  
```asm
mov DWORD PTR DS:[402000], -1
```
결과 'FF FF FF FF'로 저장된다.  
DWORD는 부호 없는 32비트 정수형이기 때문에 음수를 할당하면 2의 보수 형태로 변환되어 저장된다.  
대부분의 어셈블러는 타입을 엄격하게 검사하지 않고, 오류를 띄우지 않기 때문에 프로그래머의 주의가 필요함을 알 수 있다.  

---
## 문제 5    
**Q: Write a program that contains two instructions: (1) add the number 5 to the EAX register, and (2) add 5 to the EDX register. Generate a listing file and examine the machine code generated by the assembler. What differences, if any, did you find between the two instructions?**  
**A:** eax 레지스터에 5, edx 레지스터에 5를 더하는 명령어를 포함한 프로그램을 만들고, 리스팅 파일을 확인한다.  
```asm
.386
.MODEL FLAT, STDCALL
.STACK 4096

.code
main PROC
	add eax, 5 
	add edx, 5 
	ret
main ENDP
END main
```
해당 코드의 리스팅 파일 중  
```asm
 00000000  83 C0 05			add eax, 5 
 00000003  83 C2 05			add edx, 5 
```
add와 숫자 5에 해당하는 83과 05는 동일하다.  
반면 레지스터에 해당하는 두번째 바이트는 다르게 나타난다.  
이는 어셈블러가 사용하는 레지스터에 따라 머신 코드가 달라진다는 것을 의미하며, 어셈블리 언어가 하드웨어와 밀접하게 연결되어 있음을 보여준다.  

---
## 문제 6  
**Q: Given the number 456789ABh, list out its byte values in little-endian order.**  
**A:** AB 89 67 45  

---
## 문제 7  
**Q: Declare an array of 120 uninitialized unsigned doubleword values.**  
**A:**
```asm
.data
myArray DWORD 120 DUP(?)
```

---
## 문제 8  
**Q: Declare an array of byte and initialize it to the first 5 letters of the alphabet.**  
**A:**

---
## 문제 9  
**Q: Declare a 32-bit signed integer variable and initialize it with the smallest possible negative decimal value. (Hint: Refer to integer ranges in Chapter 1.)**  
**A:**

---
## 문제 10  
**Q: Declare an unsigned 16-bit integer variable named wArray that uses three initializers.**  
**A:**

---
## 문제 11    
**Q: Declare a string variable containing the name of your favorite color. Initialize it as a nullterminated string.**  
**A:**

---
## 문제 12  
**Q: Declare an uninitialized array of 50 signed doublewords named dArray.**  
**A:**

---
## 문제 13  
**Q: Declare a string variable containing the word “TEST” repeated 500 times.**  
**A:**

---
## 문제 14  
**Q: Declare an array of 20 unsigned bytes named bArray and initialize all elements to zero.**  
**A:**

---
## 문제 15  
**Q: Show the order of individual bytes in memory (lowest to highest) for the following doubleword variable:**  
 **val1 DWORD 87654321h**  
**A:**

---
