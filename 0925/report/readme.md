reference  
>Copilot  
>blog.naver.com/heobk11- / 어셈블리 언어  
>Assembly Language for x86 processors 7th Edition
---
[짧은 답변 문제](./short-answer.md)  
[알고리즘 워크벤치](./Algorithm-Workbench.md)  
[프로그래밍 연습](./programming-exercises.md)  
---
# 0925 수업 정리  
## 기본 정리  
1. 명령어(Mnemonic) : CPU가 수행할 작업을 나타내는 짧은 키워드 (mov, add 등)
2. 피연산자 (Operand) : 명령어의 입력값 또는 결과 저장 위치. 명령어에 따라 들어가야 하는 피연산자의 개수는 다름. 이 때, 첫 번째로 위치하는 피연산자는 무조건 목적지(destination)임. (add eax, ebx 라면 eax + ebx를 eax에 저장함)
3. 라벨(Label) : 코드나 데이터 위치를 식별하는 이름임. **코드라벨**과 **데이터라벨**로 나뉨.
4. 주석 (Comment) : 코드로써 별 의미는 없음. 우리 보기 좋으라고 달아놓는 설명.
---
## 정수 리터럴  
올리 디버거, 어셈블리에서는 기본적으로 16진수 숫자를 사용함.  
다양한 수를 저장하고 싶다면 리터럴 선언 때 알파벳을 붙여 구별해주어야 함.  
1. h : 16진수 (맨 앞이 알파벳이면 변수명으로 헷갈릴 수 있으니 0을 붙어줘야 함/ 0A8h)  
2. q, o : 8진수  
3. d : 10진수
4. b : 2진수
5. 실수도 선언해야 함 이때 형태는 (sign+integer.(integer)+(exponent))  
+3.0, -44.2E+05, 26.E5 처럼  
---
## 문자열 리터럴  
따옴표로 감싸진 알파벳 혹은 숫자 등의 문자들로 이루어진 열이다.  
'abc', 'x', 'Hello! World" 등...  
---
## 예약어  
MASM에서 사용하며 특별한 목적이 있어 특정 문맥에서만 사용 가능함.  
>명령어 니모닉 : mov, add, mul 등의 명령어  
>레지스터 이름  
>디렉티브 : MASM에게 프로그램을 어떻게 어셈블하는 지를 알림  
>속성 : BYTE, WORD 등 변수와 피연산자의 크기를 제공  
>연산자 : 수식에서 사용됨  
>미리 정의된 기호 : 어셈블 시 상수 정수 값을 반환하는 @data와 같은 기호  
---
## 식별자  
프로그래머가 선택한 이름이다. 변수, 상수, 프로시저 또는 코드 레이블 등에 사용된다.  
>1개에서 247개 사이의 문자 사용가능  
>대문자와 소문자 구별 안함  
>첫 번째 문자는 숫자여서는 안됨  
>식별자는 예약어와 같을 수 없음  
---
## 디렉티브  
어셈블러가 인식하여 그에 따라 움직이는 소스 코드에 포함된 명령.
>실행시간에 실행되지 않음  
>변수, 매크로, 프로시저를 정의 가능  
>메모리 세그먼트에 이름을 부여하고 수많은 기타 관리 작업을 수행(어셈블리와 관련된)  
>어셈블러끼리 같은 명령어 집합을 공유하더라도 각 어셈블러는 서로 완전히 다른 디렉티브 집합을 가짐  
>어셈블러 디렉티브의 가장 중요한 기능중 하나는 세그먼트 정의.  

.data (DS)  
-변수를 포함하는 프로그램 영역을 표시함.     
.code (CS)  
-실행 가능한 명령어를 포함하는 영역을 표시함.  
.stack 100h (SS)  
-스택의 크기를 설정하면서, 실행 스택을 가진 프로그램 영역을 표시함.  

---
## 명령어  
instruction은 프로그램이 어셈블되었을 때에 실행 가능하게 되는 문장.  
기본 정리에 적었던 4가지가 기본 구성 요소.  
어셈블러에 의해서 기계어 바이트들로 변환되고 실행 시간에 CPU에 의해서 적재되어 실행됨.  

---
## NOP  
No Operation. 어셈블리에서 작성 가능한 가장 안전하고 가장 쓸모없는 명령어.  
1바이트 만큼의 프로그램 공간을 차지하며 코드를 짝수 주소 경계로 정렬시키기 위해 컴파일러와 어셈블리가 때때로 사용함.  
mov ax, bx 같은 명령어는 3바이트 공간을 차지하므로 뒤에 NOP를 배치하여 4바이트로 맞춰줌.  

---
## 어셈블리 코드의 기본 뼈대  
```asm
.386
.model flat, stdcall
.stack 4096
ExitProcess PROTO, dwExitCode : DWORD ;here
.data
~~~~~~~~~~~~~~~~~~~~
.code
main PROC
  ~~~~~~~~~~~~~~~~~
  INVOKE ExitProcess, 0 ;here
main ENDP
END main
```
이다. 편의를 위해 **include Irvine32.inc**를 추가한다면 표시한 두 줄을 삭제후 main 코드를 닫기 전에 exit만 추가해주면 된다. 그 외에도 여러 명령어가 사용 가능함.  
### 리스트 파일  
우리가 코드 작성 후 소스파일을 어셈블링 하면 어셈블러가 obj파일을 만드는데, 따로 요청시 리스팅 파일 역시 만들 수 있음.  
리스트 파일은 줄번호, 오프셋 주소, 변환된 기계어 코드, 심볼 테이블이 함께 있는 프로그램 소스 코드의 복사본이 들어있음. 
얘를 들여다 보면 어셈블러의 다양한 예약어 등의 기계어 코드를 확인 가능함.  

---
## 자료형  
매우 다양함. S가 붙으면 '부호있는' 이라고 보면 됨.  
>BYTE : 8비트 정수  
>WORD : 16비트 정수  
>DWORD : 32비트 정수  
>QWORD : 64비트 정수  
>TBYTE : 압축 이진 부호화 십진수(BCD), 최상위 바이트가 80h면 음수, 00h면 양수임.  
>표준 실수 자료형은 REAL4, REAL8, REAL10을 사용함  

### DUP Operator  
상수 수식을 반복 카운터로 사용하여 여러 개의 데이터를 위한 저장 공간을 할당하며, 문자열과 배열을 위한 공간을 할당할 떼애 특히 유용함. 초기화되거나 초기화되지 않은 데이터 정의에 모두 사용가능.  
```asm
BYTE 20 DUP(0)      ;20bytes, 모두 0으로 값 초기화
BYTE 20 DUP(?)      ;20bytes, 값이 정의되지 않음
BYTE 4 DUP("STACK") ;20bytes, "STACKSTACKSTACKSTACK" 
```
---
## 리틀 엔디언과 빅 엔디언  
x86 프로세서들은 리틀 엔디언 순서를 사용하여 메모리에 데이터를 저장하고 꺼냄.  
[402000]에 12345678h 를 저장하고자 하면 402000부터 78h, 56h, 34h, 12h 순으로 저장됨.  
빅 엔디언은 반대인데, 간단히 빅 엔디언은 최상위 바이트를 먼저 저장, 리틀 엔디언은 최하위 바이트를 먼저 저장하는 식.  
빅 엔디언은 아무래도 사람이 읽기 쉽다는 장점이 있음.  
하지만 리틀 엔디언은 하위 바이트부터 접근 가능하므로 일부 연산에서 유리하고 작은 데이터 타입으로의 변환이 쉬움. 어셈블러가 보기 좋아함.  

---
## Symbolic Constant  
식별자를 정수 수식 또는 텍스트와 연관시켜 만듦.  
기억장소를 보유하지 않음.  
어셈블러가 프로그램을 스캔할 때에만 사용되며 실행 시간에는 바뀔 수 없음.  
C언어 때 #define PI=3.14 하는게 Constant, 즉 상수임.  

### =  
등호 디렉티브는 기호 이름을 정수 수식과 연관되게 함.  
a = 500 과 같이 숫자만 사용가능.  
그럼 문자, 문자열은 어떻게 정의하느냐?  

### EQU와 TEXTEQU   
EQU는 정수 수식, 임의의 텍스트 등이 들어감.  
```asm
PI EQU <3.14>
```
와 같이 정수로 계산되지 않는 값을 정의할 때에 유용함.  
<~~~> 와 같이 <> 안에 들어가면 데이터 정의로서 직접 복사되는데, 예를 들어  
```asm
m1 EQU 10*10
m2 EQU <10*10>
.
.
val1 WORD m1
val2 WORD m2
```
라고 하면 val1은 100으로 지정되지만 val2는 '10*10'이 직접 복사되어 들어감.  
EQU로 정의된 심볼은 같은 소스 코드 파일에서 다시 정의될 수 없음.  

TEXTEQU는 텍스트나 텍스트 매크로의 내용, 상수 정수 수식을 지정함.  
```asm
rowSize - 5
count TEXTEQU %(rowSize*2)
move  TEXTEQU <mov>
set   TEXTEQU <move al, count>
```
라고 하면 set은 'mov al, 10'과 같이 어셈블 되는 것.  
EQU와는 다르게 언제든지 재정의 가능함.  
