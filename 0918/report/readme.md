[True/False 문제](./True_False.md)  
[단답형 문제](./short-answer.md)  
---
# reference  
Assembly Language for x86 Processors 7th Edition.pdf  
Copilot  

---
# 0918 수업정리  

## 기본 정리
pc(personal computer)와 다른 pc(program counter)   
Instruction Pointer(IP)도 거의 같은 말이다.  
CPU가 다음에 실행할 명령어의 주소를 저장  
Location Counter(LC) : 어셈블러가 코드나 데이터를 메모리에 배치할 위치를 추적  

---
## 명령어와 RAM, CPU  
RAM은 전원을 끄면 데이터가 날라가는 휘발성 메모리.  
컴퓨터 실행시 보조기억장치에서 데이터를 RAM으로 불러온다.  
이후 주기억장치에 불러온 명령을 레지스터로 가져가 실행하는 것.(마더보드에서)  

우리가 C코드 같은걸 작성할 때 이는 주기억장치에 저장되고, save 후 컴파일 하여 실행한다면 이게 파일형태로 보조기억장치로 이동하는 것.  
메모리에 있는걸 레지스터에서 실행 후, 결과값은 다시 메모리에 가져다 놓는다.

CPU
  1. ALU : 산술 논리 연산 장치. 덧셈, 뺄셈, 곱셈, 나눗셈 같은 산술 연산과 AND, OR, NOT 같은 논리 연산을 수행한다. 하지만 막상 여기에는 덧셈기밖에 없으며, 뺄셈은 보수로, 곱셈은 덧셈의 반복으로, 나눗셈은 뺄셈의 반복으로 계산한다.(덧셈만으로 모든걸 해결하는 ALU)
  2.  CU : 제어장치. CPU내부의 모든 동작을 지시함. 명령어를 해석하여 무슨 행동을 할지 ALU, 메모리, 레지스터에 신호를 보낸다.
  3.  Clock : 동기화 및 속도 조절 장치. 우리는 시, 분, 초 사용하는 데 컴퓨터도 단위를 사용해야 할 것임. 우리가 사용하는 '초'로는 제대로 표현할 수 없으니 **클럭** 이라는 단위를 사용한다. 보통 단위는 GHz로 높을수록 더 빠르다는 뜻이다. (1GHZ라면 1초에 10억번의 클락 펄스 발생)
     input도 output도 클락 펄스에 맞추는데, 이때 제어는 CU에서

---
## 명령어 인출과 실행  
PC값에서 가리키는 주소값을 레지스터(MAR)가 전달받고 RAM으로 이동하여 찾는다.  
그와 동시에 PC값은 +1되어 바로 다음 명령어를 fetch할 준비.  
받아왔으면 레지스터(MBR, IR)에 저장하고 연산자(op코드)를 해석한다.  
이후 피연산자(오퍼랜드)를 레지스터 혹은 메모리에서 가져온다.  
Execute(실행)한다. ALU나 다른 실행 유닛이 할 것이다.  
상태 플러그를 최신화 하면 보통의 CPU가 하는 일은 끝.  

-필요시 결과를 메모리에 저장하거나 메모리에서 추가 데이터를 가져오고  
-연산 결과를 레지스터나 메모리에 저장할 수도 있다.  

---
## 부동소수점 유닛  
정수 표현 : sign + digit  
실수 표현 : sign + exponent + mantissa  
실수 표현은 복잡함 FPU가 따로 실수를 처리한다.    

## 메모리 읽기 동작  
우선 cpu의 주소 레지스터에 주소값이 들어와야 한다. + CU에서 읽기 신호가 들어오면 자동으로 메모리에 있는 주소의 내용이 데이터 레지스터로 들어간다.(RD Pin에 신호 준다.)    

## x86 프로세서의 모드들  
  1. Protected Mode : 우리가 쓰는 모드다. 운영체제에서 사용하여 프로그램이 서로의 영역을 침범하지 못하게 해 메모리 보호 기능을 제공한다. 멀티태스킹도 지원해서 여러 프로그램을 동시에 실행 가능하다. (한 컴퓨터로 카톡도 하고 메모장도 켜고 인터넷도 하는데 그거 다 제대로 동작하는거) 32비트 주소 공간을 사용하여 최대 4GB 메모리 접근 가능하다.  
  2. Real-address Mode : 20비트의 주소로 1MB 메모리만 접근 가능하다. 메모리 보호, 권한 제어, 가상 메모리가 없다. 부팅 직후, BIOS 같은 곳에서 사용한다. 부팅완료 되면 보호 모드로 전환된다.
  3. Virtual-8086 Mode : 보호 모드의 하위 기능이다. DOS 기반 프로그램이나 16비트 코드 프로그램을 실행할 수 있도록 만든 모드이다. 메모리 보호 기능은 있지만, 일부 코드에 대해 실주소 모드처럼 동작하며 가상 환경에서만 최대 1MB 주소 공간을 제공한다. 현대 OS에서는 거의 사용되지 않는다.
  4. System Management Mode : 일반 프로그램이나 OS는 접근 불가하고 하드웨어 제어, 전력 관리, 보안 기능을 수행하기 위한 비밀 공간이다. **SMI**라는 특별한 인터럽트 발생시 진입하고 주로 제조사에서 사용한다. (노트북의 절전 기능, 팬속도 조절, 하드웨어 오류 복구 등...)

---
## 외워야 할 레지스터들  
범용 레지스터  
-EAX : 누산기 레지스터  
-EBX : 베이스 레지스터  
-ECX : 카운터 레지스터  
-EDX : 데이터 레지스터  
^^얘네는 32비트, (EAX의 경우)하위 16비트는 AX, 얘를 8비트씩 쪼개면 상위 8비트는 AH, 하위 8비트는 AL   
-EBP : 베이스 포인터 레지스터  
-ESP : 스택 포인터 레지스터  
-ESI : 소스 인덱스 레지스터  
-EDI : 목적지 인덱스 레지스터  
32비트에서 E 떼면 16비트, R 붙으면 64비트라 생각하면 편하다.  
특수목적  
-EFLAGS : 상태 레지스터  
-EIP : 명령어 포인터 레지스터  
-16비트 세그먼트 레지스터 : CS, SS, DS, ES, FS, GS  

우리가 alt + Tap 눌러서 화면 전환하면 메모리에서 콘텍스트 스위칭이 발생하는데, 세그먼트 레지스터들도 함께 저장하고 복원해야 한다. 얘네들은 프로세스 간 메모리 보호와 격리에 중요한 역할을 한다.  
---
