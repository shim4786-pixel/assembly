reference  
>  
---

---
# 1016 수업 정리  
## 오퍼랜드 타입  
[label:] mnemonic [operands] [; comment] << 가 어셈블리의 일반적인 명령어 형식이다.  
여기서 **mnemonic**은 실행할 명령어, **operands**는 명령어 실행의 대상이다.  
**Operands**는  
>mnemonic  
>mnemonic A  
>mnemonic A B  
>mnemonic A B C  

와 같이 명령어에 따라 안 올 수도 여러개가 올 수도 있다.  
오퍼랜드가 붙어있다면 첫 번째 자리, 여기에서는 A에 해당하는 오퍼랜드가 **Destination**을 담당하고 (여러 개의 오퍼랜드가 존재한다면)뒤에 붙는 오퍼랜드들은 **Source**가 된다.  
명령어에 따라 실행하면 **Source**의 값이 **Destination**에 들어간다.  

오퍼랜드로 올 수 있는 타입은 3가지 있는데  
1. 즉시값(Immediate) : (EQU, = 으로 상수 정의 할 때)1+2*3과 같은 수식이 올 수 있다. 이때는 연산 결과가 저장된다. 단순히 숫자를 넣을 수도 있다.  
2. 레지스터(Register) : CPU의 고속 기억장치이다.
3. 메모리(Memory) : 메모리의 위치를 참조하여 값을 가져올 수 있다.
---
## 레지스터
**레지스터들의 이름의 앞에 E가 붙어있다면 32비트, R이 붙어있다면 64비트 크기로 알아두면 된다. 아니면 16비트다.**  
범용 레지스터들의 용도  
>EAX(Extended Accumulator Register)확장 누산기 레지스터 : 상수/ 변수 값의 저장, 연산 결과를 저장, data이동 및 일시적 저장, 입출력 명령, 곱셈과 나눗셈 명령어에서 자동으로 사용.
>EBX(Extended Base Register)확장 베이스 레지스터 : 주소의 간접 지정(데이터 접근 시 기준 주소 역할), data이동 및 일시적 저장.
>ECX(Extended Counter Register)확장 카운터 레지스터 : 반복문, 문자열 명령어, 비트 이동, 회전 명령 등에서 Count하며 제어하는 역할. CPU는 루프 카운터에서 ECX를 자동으로 사용.
>EDX(Extended Data Register)확장 데이터 레지스터 : EAX 혼자 담을 수 없는 data를 저장하는 보조 레지스터, 나눗셈 시 몫은 EAX, 나머지는 EDX에 저장.
>>이들은 입출력 주소 지정, 데이터 이동 및 일시적 저장을 담당한다. 
>ESI(Extended Source Index Register)확장 소스 인덱스 레지스터 : (복사나 비교 시)출발지 주소를 저장.
>EDI(Extended Destination Index Register)확장 목적지 인덱스 레지스터 : (복사나 비교 시)목적지 주소를 저장.
>>이들은 고속 메모리 전송 명령어에서 사용한다.
>EBP(Extended Base Pointer Register)확장 베이스 포인터 레지스터 : 고급 언어에서 스택에 있는 함수 매개 변수와 지역 변수를 참조하기 위해 사용. 스택 포인터의 기준 주소(바닥 부분)을 저장함. 고급 수준의 프로그래밍 이외의 일반적인 계산과 데이터 전송에 사용되지 않아야 함. 확장 프레임 포인터(extended frame pointer)라고도 부름. ESP와 다르게 스택이 쌓이더라도 값이 변하지 않음.
>ESP(Extended Stack Pointer Register)확장 스택 포인터 레지스터 : 현재 스택 top 위치를 표시. Stack Pointer의 가장 최근에 저장된 공간의 주소를 저장. EBP와 다르게 함수 실행동안 새로운 값이 저장시 위치가 바뀜.

특수 목적 레지스터들의 용도
>EIP(Extended Instruction Pointer Register)확장 명령어 포인터 레지스터 : 다음에 실행할 명령어의 주소를 저장. 어떤 명령어는 EIP를 조작하여 프로그램을 새 위치로 분기하게 만들기도 함.
>EFLAGS(FLAGS Register)플래그 레지스터 : CPU의 동작을 제어하거나 CPU 연산의 결과를 반영하는 개별적인 2진수 비트들로 구성된 레지스터. 아래는 연산의 결과를 나타내는 상태 플래그들임.
>>CF(Carry flag)캐리 플래그 : 부호없는 산술 연산의 결과가 너무 커 목적지에 저장이 불가능하다면 1로 세팅.
>>OF(OverFlow flag)오버플로우 플래그 : 부호있는 산술 연산의 결과가 너무 크거나 작아 목적지에 저장 불가능하다면 1로 세팅.
>>SF(Sign flag)부호 플래그 : 산술 논리 연산의 결과가 음수라면 1로 세팅.
>>ZF(Zero flag)제로 플래그 : 산술 논리 연산의 결과가 0이라면 1로 세팅.
>>AC(Auxiliary Carry flag)보조 캐리 플래그 : 산술 연산이 8비트 피연산자에서 비트 3에서 비트4로의 캐리가 발생했을 때 1로 세팅.
>>PF(Parity flag)패리티 플래그 : 결과의 1의 개수가 짝수라면 1로 세팅.(데이터가 바뀌었거나 훼손될 가능성 있을 시 오류 검사에 사용)
>세그먼트 레지스터 : 메모리를 나누어 세그먼트 단위로 접속할 수 있도록 기준이 되는 세그먼트들의 시작 주소를 저장하는 레지스터들 모두 16비트의 크기를 가짐.
>>CS(Code Segment)코드 세그먼트 레지스터 : 어셈블리에서 .code로 선언된 영역/ 실행중인(혹은 실행할) 코드가 위치한 메모리 영역을 지정.
>>DS(Data Segment)데이터 세그먼트 레지스터 : 어셈블리에서 .data로 선언된 영역(c언어의 프로그램 주소 공간에서 데이터, 힙, 스택에 해당하는 부분)/ 일반 데이터가 위치한 메모리 영역을 지정.
>>SS(Stack Segment)스택 세그먼트 레지스터 : .stack으로 정의된 스택 영역의 시작 주소를 저장.
>>ES(Extra Segment)보조 세그먼트 레지스터 : 추가 데이터 접근용 보조 세그먼트
>>FS(File/Far Segment)시스템 세그먼트 레지스터 : (OS에 따라 용도는 다르지만)운영체제 또는 스레드 관련 데이터 접근.
>>GS(Global/General Segment)전역 세그먼트 레지스터 : (OS에 따라 용도는 다르지만)커널 구조체나 데이터 접근에 사용.
---


