reference
>Copilot  
>blog.naver.com/heobk11- / 어셈블리 언어  
>intelligentcm.tistory.com/category/Assembly  
>Assembly Language for x86 processors 7th Edition  
---

---
# 1106 수업 정리  
## 부울과 비교 명령어  
AND, OR, XOR, NOT 연산이 1장에서 대표적으로 소개된 비교 명령어이다.  
해당 연산들은 2진수 비트 단위에서 수행된다.  
부울 명령어는 Zero, Carry, Sign, Overflow, Parity 플래그에 영향을 준다.  
>Zero : 연산 결과가 0이면 1로 세팅  
>Carry : 목적지 피연산자의 MSB에서 캐리 올림(내림)이 발생할 경우 1로 세팅  
>Sign : 연산 결과 피연산자의 MSB가 1이면 1, 아니면 0(세팅되었다면 음수임을 나타냄)  
>Overflow : 부호있는 수의 연산결과 유효하지 않은 값(너무 크거나 너무 작거나)을 생성할 때 1로 세팅  
>Parity : 목적지 피연산자의 하위 바이트에 1이 짝수 개 있다면 1로 세팅  

### AND  
지정되는 두 피연산자의 대응되는 각 비트 쌍에 대해 부울 AND 연산을 수행하고 목적지에 저장한다.  
앞으로 정리할 대부분의 비교 명령어들이 그렇듯이 연산을 수행한 뒤  
값을 저장할 곳이 필요하기 때문에 목적지에 즉시값이 올 수는 없다.(당연히 mem to mem도 안된다.)   
1011 AND 0010 => 0010  
| x | y | x ∧ y |
|---|---|--------|
| 0 | 0 |   0    |
| 0 | 1 |   0    |
| 1 | 0 |   0    |
| 1 | 1 |   1    |

두 비트가 모두 1이면 1이고 아니면 0이라는 규칙이 적용된다.  
비트 마스크(덮어씌우는 값)를 이용, 0으로 모든 비트를 클리어하거나 1로 원하는 비트값을 가져올 수 있다.  
ex) 알파벳 대문자와 소문자는 20h만큼 차이난다. 100000b 의 차이이므로 `AND 11011111`로 모든 알파벳을 대문자로 통일할 수 있다.  
많은 검색 엔진은 이를 이용하여 우리가 입력한 영문자를 모두 대문자로 바꾼 뒤 검색한다.  

### OR  
지정되는 두 피연산자의 대응되는 각 비트 쌍에 대해 부울 OR 연산을 수행하고 목적지에 저장한다.  
AND 명령어와 마찬가지로 오버플로우, 캐리비트를 클리어(0)하는 명령어이다.   
OR 명령어는 AND 명령어와 동일하게 다음과 같은 피연산자의 조합을 사용한다.  
>`OR reg, reg`  
>`OR reg, mem`  
>`OR reg, imm`  
>`OR mem, reg`  
>`OR mem, imm`  

| x | y | x ∨ y |
|---|---|--------|
| 0 | 0 |   0    |
| 0 | 1 |   1    |
| 1 | 0 |   1    |
| 1 | 1 |   1    |

입력 비트 중 하나라도 1이면 1이다.  
다른 비트에 영향을 주지않고 1개 이상의 비트들을 1로 설정할 때에 유용하다.  
AND와는 반대로 0으로 원하는 비트값을 가져오거나 1로 원하는 비트를 세팅할 수 있다.  
`OR al, al` 연산으로 AL 자신에 대한 값을 Zero와 Sign플래그로 알 수 있다.  
Zero=1 => 0,  `Zero=0`일 때, Sign=1 => 0보다 작다, Sign=0 => 0보다 크다.  

### XOR  
지정되는 두 피연산자의 대응되는 각 비트 쌍에 대해 부울 XOR 연산을 수행하고 목적지에 저장한다.  
기본적인 특징은 AND, OR과 동일하다.  
| x | y | x ⊕ y |
|---|---|--------|
| 0 | 0 |   0    |
| 0 | 1 |   1    |
| 1 | 0 |   1    |
| 1 | 1 |   0    |

두 비트 값이 같으면 0, 다르면 1이라는 규칙을 갖는다.  
| x | y | x ⊕ y | (x ⊕ y) ⊕ y |
|---|---|-------|---------------|
| 0 | 0 |   0   |      0        |
| 0 | 1 |   1   |      0        |
| 1 | 0 |   1   |      1        |
| 1 | 1 |   0   |      1        |

위 표는 XOR의 역연산 성질을 보여준다. 마지막 값은 x 본인과 똑같은데,  
XOR은 같은 피연산자에 대해서 두 번 적용할 때 자신으로 되돌아온다. x에 y를 두 번 적용한 결과 x 자신으로 되돌아왔다.  
패리티 검사에 사용되기도 한다. 어떠한 숫자를 0과 XOR하는 것이 제일 효과적인 패리티 검사 방법이다.  

### NOT  
피연산자의 모든 비트를 반대로 바꾼다.  
결과는 1의 보수라고 부르며 피연산자는 즉시값일 수 없다.  
ex) 11110000b의 NOT은 00001111b이며, 이는 11110000의 1의 보수이다.  
어떠한 플래그에도 영향을 주지 않는다.  

### TEST  
AND와 동일하다.  
AND와의 차이점은 목적지 피연산자의 값을 변경하지 않는다는 것이다.  
그저 연산 결과에 따라 Sign, Zero, Parity 플래그를 수정한다.  
Overflow와 Carry 플래그를 항상 클리어한다.  

### CMP  
SUB와 동일하다.  
SUB와의 차이점은 목적지 피연산자의 값을 변경하지 않는다는 것이다.  

| CMP 결과         | Zero Flag (ZF) | Carry Flag (CF) |
|------------------|----------------|------------------|
| Destination > Source |       0        |        0         |
| Destination < Source |       0        |        1         |
| Destination == Source|       1        |        0         |

뺄셈이 실제로 수행되었다면 목적지 피연산자가 가졌을 값에 따라 플래그 값을 변화시키는데,  
두 부호없는 피연산자를 비교할 때에 Zero와 Carry 플래그는 위와 같은 관계를 나타낸다.  

| CMP 결과         | 플래그                       |
|------------------|-----------------------------|
| Destination > Source | SF = OF                 |
| Destination < Source | SF ≠ OF                 |
| Destination == Source| ZF = 1                  |

부호있는 피연산자를 비교할 때에는 다음과 같은 관계를 가진다.  

## 이외  
이러한 비교 명령어들로 플래그를 바꿀 수 있지만,  
`st-`, `cl-`으로도 가능하다.  
ex) `stc`=> Carry 플래그를 1로 셋한다.  
    `clc`=> Carry 플래그를 0으로 클리어한다.  
다른 플래그도 가능하다.  

## 조건부 점프  
### Jcond 명령어  
상태 플래그 조건이 참이면 목적지 레이블로 점프(분기)하는 명령어이다.  

J(조건) 식으로 붙는데, J는 점프하라는 뜻이고, N이 있으면 NOT이라는 뜻이다.  
JN(값) 식으로 붙으면 해당 값이 0이면 점프하라는 뜻이다.  
Zero는 Z, Carry는 C, Overflow는 O, Sign은 S, Parity는 P가 붙는다.  
ex) JO => 오버플로우 플래그가 0이 아니면 점프해라  
    JNZ => 제로 플래그가 0이면 점프해라  

뒤에 붙는 값은 꼭 플래그가 아니어도 상관없다.  
E가 붙으면 equal(','로 구분된 두 피연산자의 값이 같으면)이면 점프하라는 뜻이다.  
JNE는 두 피연산자의 값이 같지 않으면 점프하라는 뜻이 되겠다.  

JZ는 JE와 같고, JNZ는 JNE와 같은데, 무엇을 선택할지는 본인의 책임이다.  
내가 무슨 의도로 이 명령어를 사용하였는지에 따라 알맞은 명령어를 선택하면 된다.  

J(레지스터)Z 도 가능하다.  
ex) JCXZ => CX = 0이면 점프하라.  

부호없는 비교에 따르는 점프에서는 Above와 Below의 뜻으로 A, B를 사용하고  
부호있는 비교에 따르는 점프에서는 Greater와 Less의 뜻으로 G, L을 사용한다.  
무엇이 작고 큰지 따지는건 목적지 피연산자 기준이다.  

위의 표를 참고하여 플래그를 보고 분기하기에 Jcond 명령어 이전에는 cmp나 Test 등 비교 명령어가 와야 정확히 사용 가능하다.  

## 조건부 루프  
### LOOPZ와 LOOPE 명령어  
LOOP와 동일하다. (하나의 추가 조건을 가진 것만 뺀다면)  
`ZERO = 1`  
Zero이면 루프하라는 뜻이다. LOOPZ와 LOOPE는 같다. 마찬가지로 내 의지에 맞게 알맞은 명령어를 사용한다.  

### LOOPNZ와 LOOPNE 명령어  
위 명령어에 N이 들어왔으니 당연히 반대이다.  
`ZERO = 0`  
Zero가 아니면 루프하라는 뜻이다. 이하동문이다.  

## 조건부 구조  
어셈블리에서는 
```asm
.IF (조건1)
  실행문1
.ELSEIF (조건2)
  실행문2
.ENDIF
```
와 같은 구조가 사용가능하다.  
중요한 것은 IF, WHILE과 같이 고급언어에서 사용하던 조건부 구조문이  
어셈블리어로는 어떻게 변환되는지를 아는 것이다.  
조건에서 AND, OR을 쓸 때는 (&&, ||)를 사용한다.  
